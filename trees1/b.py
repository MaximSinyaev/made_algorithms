"""
–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–≤–æ–∏—á–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –¥–µ—Ä–µ–≤–æ–º, –∏—Ö –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 100. –í –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –æ–¥–Ω–∞ –∏–∑
—Å–ª–µ–¥—É—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π:

    insert ùë• ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –≤ –¥–µ—Ä–µ–≤–æ –∫–ª—é—á ùë•. –ï—Å–ª–∏ –∫–ª—é—á ùë• –µ—Å—Ç—å –≤ –¥–µ—Ä–µ–≤–µ, —Ç–æ –Ω–∏—á–µ–≥–æ –¥–µ–ª–∞—Ç—å –Ω–µ –Ω–∞–¥–æ;
    delete ùë• ‚Äî —É–¥–∞–ª–∏—Ç—å –∏–∑ –¥–µ—Ä–µ–≤–∞ –∫–ª—é—á ùë•. –ï—Å–ª–∏ –∫–ª—é—á–∞ ùë• –≤ –¥–µ—Ä–µ–≤–µ –Ω–µ—Ç, —Ç–æ –Ω–∏—á–µ–≥–æ –¥–µ–ª–∞—Ç—å –Ω–µ –Ω–∞–¥–æ;
    exists ùë• ‚Äî –µ—Å–ª–∏ –∫–ª—é—á ùë• –µ—Å—Ç—å –≤ –¥–µ—Ä–µ–≤–µ –≤—ã–≤–µ–¥–∏—Ç–µ ¬´true¬ª, –µ—Å–ª–∏ –Ω–µ—Ç ¬´false¬ª;
    next ùë• ‚Äî –≤—ã–≤–µ–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ, —Å—Ç—Ä–æ–≥–æ –±–æ–ª—å—à–∏–π ùë•, –∏–ª–∏ ¬´none¬ª –µ—Å–ª–∏ —Ç–∞–∫–æ–≥–æ –Ω–µ—Ç;
    prev ùë• ‚Äî –≤—ã–≤–µ–¥–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ, —Å—Ç—Ä–æ–≥–æ –º–µ–Ω—å—à–∏–π ùë•, –∏–ª–∏ ¬´none¬ª –µ—Å–ª–∏ —Ç–∞–∫–æ–≥–æ –Ω–µ—Ç.

–í –¥–µ—Ä–µ–≤–æ –ø–æ–º–µ—â–∞—é—Ç—Å—è –∏ –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, –Ω–µ –ø—Ä–µ–≤—ã—à–∞—é—â–∏–µ –ø–æ –º–æ–¥—É–ª—é 10^9.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í—ã–≤–µ–¥–∏—Ç–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π exists, next, prev. –°–ª–µ–¥—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç—É –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∏–∑
–ø—Ä–∏–º–µ—Ä–∞.
"""
import sys

SEPARATOR = "\n"
UNICODE = "utf-8"


class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

    def __repr__(self):
        return f'(key: {self.key}, height: {self.height}) <left: {self.left} right: {self.right}>'


class AVSBinaryTree:
    def __init__(self):
        self.root = None

    def exists(self, key):
        return self._exists(key, self.root)

    def _exists(self, key, node):
        if node is None:
            return False
        elif key == node.key:
            return True
        elif key < node.key:
            return self._exists(key, node.left)
        elif key > node.key:
            return self._exists(key, node.right)

    @staticmethod
    def get_height(node):
        if node:
            return node.height
        return 0

    def insert(self, key):
        self.root = self._insert(key, self.root)

    def _insert(self, key, node: Node):
        if node is None:
            return Node(key)
        elif key < node.key:
            node.left = self._insert(key, node.left)
        elif key > node.key:
            node.right = self._insert(key, node.right)
        node.height = max(self.get_height(node.left),
                          self.get_height(node.right)) + 1
        return self.balance(node)
        # return node

    def next(self, key):
        return self._next(key, self.root)

    def _next(self, key, node: Node, last_next=None):
        if node is None:
            return last_next
        elif key < node.key:
            last_next = node.key if (last_next is None) or (node.key < last_next) else last_next
            return self._next(key, node.left, last_next)
        else:
            return self._next(key, node.right, last_next)

    def prev(self, key):
        return self._prev(key, self.root)

    def _prev(self, key, node: Node, last_prev=None):
        if node is None:
            return last_prev
        elif key <= node.key:
            return self._prev(key, node.left, last_prev)
        else:
            last_prev = node.key if (last_prev is None) or (node.key > last_prev) else last_prev
            return self._prev(key, node.right, last_prev)

    def find_max(self, node=None):
        if node is None:
            return node
        while node.right:
            node = node.right
        return node

    def find_min(self, node=None):
        if node is None:
            return node
        while node.left:
            node = node.left
        return node

    def delete(self, key):
        # print(self.root)
        self.root = self._delete(key, self.root)

    def _delete(self, key, node: Node):
        if node is None:
            return None
        elif key == node.key:
            if node.left is not None and node.right is not None:
                node.key = self.find_max(node.left).key
                node.left = self._delete(node.key, node.left)
            elif node.left is None:
                node = node.right
            elif node.right is None:
                node = node.left
            else:
                del Node
                node = None
        elif key < node.key:
            node.left = self._delete(key, node.left)
        elif key > node.key:
            node.right = self._delete(key, node.right)
        return self.balance(node)

    # Balancing funcs
    def count_balance(self, node):
        if node:
            return self.get_height(node.left) - self.get_height(node.right)
        return 0

    def fix_height(self, node):
        if node:
            node.height = max(self.get_height(node.left),
                              self.get_height(node.right)) + 1

    def balance(self, node):
        self.fix_height(node)
        balance = self.count_balance(node)
        # print(f'Balance of node {node} is {balance}')
        if balance < -1:
            if self.count_balance(node.right) > 0:
                node.right = self.right_rotate(node.right)
            return self.left_rotate(node)
        if balance > 1:
            if self.count_balance(node.left) < 0:
                node.right = self.left_rotate(node.left)
            return self.right_rotate(node)
        return node

    def left_rotate(self, node):
        new_root = node.right
        node.right = new_root.left
        new_root.left = node
        self.fix_height(node)
        self.fix_height(new_root)
        return new_root

    def right_rotate(self, node):
        new_root = node.left
        node.left = new_root.right
        new_root.right = node
        self.fix_height(node)
        self.fix_height(new_root)
        return new_root


if __name__ == '__main__':
    raw_input = sys.stdin.buffer.read().splitlines()
    result_exists = list()
    my_tree = AVSBinaryTree()
    for operation in raw_input:
        operation = operation.decode(UNICODE)
        op, val = operation.split()
        val = int(val)
        if op == 'insert':
            my_tree.insert(val)
            print(my_tree.root)
        elif op == 'exists':
            print(str(my_tree.exists(val)).lower())
        elif op == 'next':
            print(str(my_tree.next(val)).lower())
        elif op == 'prev':
            print(str(my_tree.prev(val)).lower())
        elif op == 'delete':
            my_tree.delete(val)
            print(my_tree.root)

    print(my_tree.root)
